-- Made by 0x1000007e

-- rulu: Emitter
-- Emits Lua code from AST

local Emitter = {}
Emitter.__index = Emitter

local function indent_str(depth)
  return string.rep("  ", depth)
end

local function to_lua_operator(op)
  if op == "!" then return "not" end
  if op == "&&" then return "and" end
  if op == "||" then return "or" end
  if op == "!=" then return "~=" end
  return op
end

function Emitter.new()
  return setmetatable({ lines = {}, depth = 0, label_counter = 0, continue_label_stack = {}, _module_stack = {}, _known_modules = {} }, Emitter)
end

function Emitter:emit(line)
  table.insert(self.lines, (indent_str(self.depth) .. (line or "")))
end

function Emitter:with_indent(fn)
  self.depth = self.depth + 1
  fn()
  self.depth = self.depth - 1
end

function Emitter:gen_temp(prefix)
  self.label_counter = self.label_counter + 1
  return string.format("__rulu_%s_%d", prefix or "t", self.label_counter)
end

function Emitter:push_continue_label()
  local label = self:gen_temp("cont")
  table.insert(self.continue_label_stack, label)
  return label
end

function Emitter:pop_continue_label()
  table.remove(self.continue_label_stack)
end

function Emitter:current_continue_label()
  return self.continue_label_stack[#self.continue_label_stack]
end

function Emitter:emit_program(ast)
  self:emit("-- generated by rulu")
  -- Prelude: small standard helpers
  self:emit("local function println(...) print(...) end")
  self:emit("local function range(a, b, step)\n  a = a or 1\n  b = b or a\n  if a == b then return { a } end\n  step = step or (a <= b and 1 or -1)\n  local t = {}\n  if step > 0 then\n    for i = a, b, step do t[#t+1] = i end\n  else\n    for i = a, b, step do t[#t+1] = i end\n  end\n  return t\nend")
  if ast.moduleName then
    self:emit("local M = {} -- module: " .. ast.moduleName)
    table.insert(self._module_stack, { var = "M", deferred_reexports = {} })
  else
    -- no module
  end
  for _, stmt in ipairs(ast.body) do
    -- Ignore bare ModuleDecl in executable files (dependency declaration)
    if stmt.kind ~= "ModuleDecl" then
      self:emit_statement(stmt)
    end
  end
  if ast.moduleName then
    -- flush any deferred re-exports for root module
    local cur = self._module_stack[#self._module_stack]
    if cur then self:flush_deferred_reexports(cur) end
    self:emit("return M")
    table.remove(self._module_stack)
  end
  return table.concat(self.lines, "\n") .. "\n"
end

function Emitter:flush_deferred_reexports(cur)
  for _, entry in ipairs(cur.deferred_reexports or {}) do
    local base = cur.var
    for _, p in ipairs(entry.baseParts or {}) do
      base = base .. "." .. p
    end
    for _, name in ipairs(entry.items or {}) do
      self:emit(string.format("%s.%s = %s.%s", cur.var, name, base, name))
    end
  end
  cur.deferred_reexports = {}
end

function Emitter:emit_block(block)
  for _, stmt in ipairs(block.body) do
    self:emit_statement(stmt)
  end
end

function Emitter:emit_block_with_ctx(block, ctx)
  for _, stmt in ipairs(block.body) do
    if ctx.guard_active.value then
      self:emit("if not " .. ctx.guard_var .. " then")
      self:with_indent(function()
        self:emit_statement_with_ctx(stmt, ctx)
      end)
      self:emit("end")
    else
      self._encountered_continue = false
      self:emit_statement_with_ctx(stmt, ctx)
      if self._encountered_continue then
        ctx.guard_active.value = true
      end
    end
  end
end

function Emitter:emit_statement(stmt)
  return self:emit_statement_with_ctx(stmt, nil)
end

function Emitter:emit_statement_with_ctx(stmt, ctx)
  local k = stmt.kind
  if k == "Function" then
    local names = {}
    for _, p in ipairs(stmt.params) do table.insert(names, p.name) end
    local cur = self._module_stack[#self._module_stack]
    if cur and stmt.isPublic then
      self:emit(string.format("function %s.%s(%s)", cur.var, stmt.name, table.concat(names, ", ")))
    elseif cur then
      self:emit(string.format("local function %s(%s)", stmt.name, table.concat(names, ", ")))
    else
      self:emit(string.format("function %s(%s)", stmt.name, table.concat(names, ", ")))
    end
    self:with_indent(function()
      self:emit_block(stmt.body)
    end)
    self:emit("end")
  elseif k == "Let" then
    if stmt.init then
      self:emit("local " .. stmt.name .. " = " .. self:emit_expression(stmt.init))
    else
      self:emit("local " .. stmt.name)
    end
  elseif k == "Assign" then
    self:emit(stmt.name .. " = " .. self:emit_expression(stmt.value))
  elseif k == "Return" then
    if stmt.argument then
      self:emit("return " .. self:emit_expression(stmt.argument))
    else
      self:emit("return")
    end
  elseif k == "If" then
    self:emit("if " .. self:emit_expression(stmt.test) .. " then")
    self:with_indent(function()
      if ctx then self:emit_block_with_ctx(stmt.consequent, ctx) else self:emit_block(stmt.consequent) end
    end)
    if stmt.alternate then
      self:emit("else")
      self:with_indent(function()
        if ctx then self:emit_block_with_ctx(stmt.alternate, ctx) else self:emit_block(stmt.alternate) end
      end)
    end
    self:emit("end")
  elseif k == "While" then
    self:emit("while " .. self:emit_expression(stmt.test) .. " do")
    self:with_indent(function()
      local guard_var = self:gen_temp("contflag")
      self:emit("local " .. guard_var .. " = false")
      local subctx = { guard_var = guard_var, guard_active = { value = false }, inside_loop = true }
      self:emit_block_with_ctx(stmt.body, subctx)
    end)
    self:emit("end")
  elseif k == "ForRange" then
    local start_code = self:emit_expression(stmt.startExpr)
    local end_code = self:emit_expression(stmt.endExpr)
    local step_code
    if stmt.stepExpr then
      step_code = self:emit_expression(stmt.stepExpr)
    elseif stmt.inclusive then
      step_code = nil -- default step from start/end sign
    else
      step_code = nil -- default
    end
    if stmt.inclusive then
      -- Inclusive range: adjust end depending on step
      local s = self:gen_temp("step")
      local e = self:gen_temp("end")
      self:emit(string.format("local %s = %s", e, end_code))
      if step_code then
        self:emit(string.format("local %s = %s", s, step_code))
        self:emit(string.format("for %s = %s, %s, %s do", stmt.var, start_code, e, s))
      else
        self:emit(string.format("for %s = %s, %s do", stmt.var, start_code, e))
      end
    else
      if step_code then
        self:emit(string.format("for %s = %s, %s, %s do", stmt.var, start_code, end_code, step_code))
      else
        self:emit(string.format("for %s = %s, %s do", stmt.var, start_code, end_code))
      end
    end
    self:with_indent(function()
      local guard_var = self:gen_temp("contflag")
      self:emit("local " .. guard_var .. " = false")
      local subctx = { guard_var = guard_var, guard_active = { value = false }, inside_loop = true }
      self:emit_block_with_ctx(stmt.body, subctx)
    end)
    self:emit("end")
  elseif k == "ForEach" then
    local iter = self:emit_expression(stmt.iterExpr)
    local idx = self:gen_temp("i")
    self:emit(string.format("for %s = 1, #(%s) do", idx, iter))
    self:with_indent(function()
      self:emit(string.format("local %s = (%s)[%s]", stmt.var, iter, idx))
      local guard_var = self:gen_temp("contflag")
      self:emit("local " .. guard_var .. " = false")
      local subctx = { guard_var = guard_var, guard_active = { value = false }, inside_loop = true }
      self:emit_block_with_ctx(stmt.body, subctx)
    end)
    self:emit("end")
  elseif k == "Loop" then
    self:emit("while true do")
    self:with_indent(function()
      local guard_var = self:gen_temp("contflag")
      self:emit("local " .. guard_var .. " = false")
      local subctx = { guard_var = guard_var, guard_active = { value = false }, inside_loop = true }
      self:emit_block_with_ctx(stmt.body, subctx)
    end)
    self:emit("end")
  elseif k == "Break" then
    self:emit("break")
  elseif k == "Continue" then
    if not ctx or not ctx.inside_loop then
      self:emit("error('continue used outside of loop')")
    else
      self:emit(ctx.guard_var .. " = true")
      self._encountered_continue = true
    end
  elseif k == "Match" then
    local tmp = self:gen_temp("scrut")
    self:emit("local " .. tmp .. " = " .. self:emit_expression(stmt.discriminant))
    local first = true
    for _, arm in ipairs(stmt.arms) do
      if arm.pattern.kind == "PatternLiteral" then
        local cond = tmp .. " == " .. self:emit_expression(arm.pattern.value)
        if first then
          self:emit("if " .. cond .. " then")
          first = false
        else
          self:emit("elseif " .. cond .. " then")
        end
        self:with_indent(function()
          self:emit_block(arm.body)
        end)
      elseif arm.pattern.kind == "PatternWildcard" then
        if first then
          self:emit("do")
          self:with_indent(function()
            self:emit_block(arm.body)
          end)
          self:emit("end")
          first = false
        else
          self:emit("else")
          self:with_indent(function()
            self:emit_block(arm.body)
          end)
          self:emit("end")
        end
      else
        error("Unsupported match pattern kind: " .. tostring(arm.pattern.kind))
      end
    end
    if not first then
      -- if/elseif/else already emitted end in branches except last elseif case
      -- Ensure an end if last branch wasn't wildcard
      local has_wild = stmt.hasWildcard or false
      if not has_wild then
        self:emit("end")
      end
    end
  elseif k == "Use" then
    -- support: use path::to::{a,b}; and pub use
    local function emit_single(parts, localname)
      local req = table.concat(parts, ".")
      self:emit(string.format("local %s = require(%q)", localname, req))
    end
    if stmt.items and #stmt.items > 0 then
      -- group import
      local cur = self._module_stack[#self._module_stack]
      local first = stmt.parts[1]
      if cur and first == "self" and stmt.isPublic then
        -- defer re-export from self::<path>::{items} until after module body emitted
        local baseParts = {}
        for i = 2, #stmt.parts do table.insert(baseParts, stmt.parts[i]) end
        table.insert(cur.deferred_reexports, { baseParts = baseParts, items = stmt.items })
      else
        local prefix = {}
        for i, p in ipairs(stmt.parts) do
          if not (i == 1 and (p == "crate" or p == "self")) then
            table.insert(prefix, p)
          end
        end
        local modname = table.concat(prefix, ".")
        self:emit(string.format("local __use = require(%q)", modname))
        for _, item in ipairs(stmt.items) do
          local name = item
          self:emit(string.format("local %s = __use.%s", name, name))
        end
      end
    else
      local parts = {}
      for i, p in ipairs(stmt.parts) do
        if not (i == 1 and (p == "crate" or p == "self")) then
          table.insert(parts, p)
        end
      end
      local localname = stmt.alias or (parts[#parts] or stmt.parts[#stmt.parts])
      if localname and #parts > 0 then
        emit_single(parts, localname)
      else
        self:emit("-- use (ignored): " .. table.concat(stmt.parts, "::"))
      end
    end
  elseif k == "Const" then
    local line = ("%s = %s"):format(stmt.name, self:emit_expression(stmt.value))
    local cur = self._module_stack[#self._module_stack]
    if cur and stmt.isPublic then
      self:emit(cur.var .. "." .. line)
    elseif cur then
      self:emit("local " .. line)
    else
      self:emit("local " .. line)
    end
  elseif k == "ExprStmt" then
    local code = self:emit_expression(stmt.expression)
    self:emit(code)
  elseif k == "Module" then
    -- nested module block
    local parent = self._module_stack[#self._module_stack]
    local modvar = stmt.name
    self:emit("local " .. modvar .. " = {}")
    table.insert(self._module_stack, { var = modvar, deferred_reexports = {} })
    self._known_modules[modvar] = true
    -- emit body inside module context
    -- two-pass: first nested modules, then others
    local first_pass = {}
    local second_pass = {}
    for _, it in ipairs(stmt.body or {}) do
      if it.kind == "Module" then table.insert(first_pass, it) else table.insert(second_pass, it) end
    end
    for _, it in ipairs(first_pass) do self:emit_statement(it) end
    for _, it in ipairs(second_pass) do self:emit_statement(it) end
    -- flush deferred re-exports for this module
    local cur = self._module_stack[#self._module_stack]
    if cur then self:flush_deferred_reexports(cur) end
    table.remove(self._module_stack)
    if parent and stmt.isPublic then
      self:emit(string.format("%s.%s = %s", parent.var, stmt.name, modvar))
    end
  else
    error("Unknown statement kind: " .. tostring(k))
  end
end

function Emitter:emit_expression(expr)
  local k = expr.kind
  if k == "Literal" then
    if expr.literalType == "string" then
      return string.format("%q", expr.value)
    elseif expr.literalType == "boolean" then
      return expr.value and "true" or "false"
    else
      return tostring(expr.value)
    end
  elseif k == "Identifier" then
    return expr.name
  elseif k == "Unary" then
    local op = to_lua_operator(expr.operator)
    if op == "not" then
      return "not " .. self:emit_expression(expr.argument)
    else
      return op .. self:emit_expression(expr.argument)
    end
  elseif k == "Binary" then
    local op = to_lua_operator(expr.operator)
    return "(" .. self:emit_expression(expr.left) .. " " .. op .. " " .. self:emit_expression(expr.right) .. ")"
  elseif k == "Call" then
    local args = {}
    for _, a in ipairs(expr.arguments) do table.insert(args, self:emit_expression(a)) end
    return self:emit_expression(expr.callee) .. "(" .. table.concat(args, ", ") .. ")"
  elseif k == "Member" then
    return self:emit_expression(expr.object) .. "." .. expr.property
  elseif k == "PathAccess" then
    -- Prefer local module variable, otherwise require
    if expr.module == "self" then
      local cur = self._module_stack[#self._module_stack]
      if cur then
        return string.format("%s.%s", cur.var, expr.property)
      end
    end
    if self._known_modules[expr.module] then
      return string.format("%s.%s", expr.module, expr.property)
    end
    return string.format("require(%q).%s", expr.module, expr.property)
  elseif k == "Index" then
    return self:emit_expression(expr.object) .. "[" .. self:emit_expression(expr.index) .. "]"
  elseif k == "ArrayLiteral" then
    local parts = {}
    for _, e in ipairs(expr.elements) do table.insert(parts, self:emit_expression(e)) end
    return "{" .. table.concat(parts, ", ") .. "}"
  else
    error("Unknown expression kind: " .. tostring(k))
  end
end

return Emitter


