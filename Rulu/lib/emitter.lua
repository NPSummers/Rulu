-- Made by 0x1000007e

-- rulu: Emitter
-- Emits Lua code from AST

local Emitter = {}
Emitter.__index = Emitter

local function indent_str(depth)
  return string.rep("  ", depth)
end

local function to_lua_operator(op)
  if op == "!" then return "not" end
  if op == "&&" then return "and" end
  if op == "||" then return "or" end
  if op == "!=" then return "~=" end
  return op
end

function Emitter.new()
  return setmetatable({ lines = {}, depth = 0, label_counter = 0, continue_label_stack = {} }, Emitter)
end

function Emitter:emit(line)
  table.insert(self.lines, (indent_str(self.depth) .. (line or "")))
end

function Emitter:with_indent(fn)
  self.depth = self.depth + 1
  fn()
  self.depth = self.depth - 1
end

function Emitter:gen_temp(prefix)
  self.label_counter = self.label_counter + 1
  return string.format("__rulu_%s_%d", prefix or "t", self.label_counter)
end

function Emitter:push_continue_label()
  local label = self:gen_temp("cont")
  table.insert(self.continue_label_stack, label)
  return label
end

function Emitter:pop_continue_label()
  table.remove(self.continue_label_stack)
end

function Emitter:current_continue_label()
  return self.continue_label_stack[#self.continue_label_stack]
end

function Emitter:emit_program(ast)
  self:emit("-- generated by rulu")
  if ast.moduleName then
    self:emit("local M = {} -- module: " .. ast.moduleName)
  end
  for _, stmt in ipairs(ast.body) do
    self:emit_statement(stmt)
  end
  if ast.moduleName then
    self:emit("return M")
  end
  return table.concat(self.lines, "\n") .. "\n"
end

function Emitter:emit_block(block)
  for _, stmt in ipairs(block.body) do
    self:emit_statement(stmt)
  end
end

function Emitter:emit_block_with_ctx(block, ctx)
  for _, stmt in ipairs(block.body) do
    if ctx.guard_active.value then
      self:emit("if not " .. ctx.guard_var .. " then")
      self:with_indent(function()
        self:emit_statement_with_ctx(stmt, ctx)
      end)
      self:emit("end")
    else
      self._encountered_continue = false
      self:emit_statement_with_ctx(stmt, ctx)
      if self._encountered_continue then
        ctx.guard_active.value = true
      end
    end
  end
end

function Emitter:emit_statement(stmt)
  return self:emit_statement_with_ctx(stmt, nil)
end

function Emitter:emit_statement_with_ctx(stmt, ctx)
  local k = stmt.kind
  if k == "Function" then
    local names = {}
    for _, p in ipairs(stmt.params) do table.insert(names, p.name) end
    if stmt.isPublic and #self.lines > 0 and self.lines[2] and self.lines[2]:match("^local M = ") then
      self:emit(string.format("function M.%s(%s)", stmt.name, table.concat(names, ", ")))
    else
      self:emit(string.format("function %s(%s)", stmt.name, table.concat(names, ", ")))
    end
    self:with_indent(function()
      self:emit_block(stmt.body)
    end)
    self:emit("end")
  elseif k == "Let" then
    if stmt.init then
      self:emit("local " .. stmt.name .. " = " .. self:emit_expression(stmt.init))
    else
      self:emit("local " .. stmt.name)
    end
  elseif k == "Assign" then
    self:emit(stmt.name .. " = " .. self:emit_expression(stmt.value))
  elseif k == "Return" then
    if stmt.argument then
      self:emit("return " .. self:emit_expression(stmt.argument))
    else
      self:emit("return")
    end
  elseif k == "If" then
    self:emit("if " .. self:emit_expression(stmt.test) .. " then")
    self:with_indent(function()
      if ctx then self:emit_block_with_ctx(stmt.consequent, ctx) else self:emit_block(stmt.consequent) end
    end)
    if stmt.alternate then
      self:emit("else")
      self:with_indent(function()
        if ctx then self:emit_block_with_ctx(stmt.alternate, ctx) else self:emit_block(stmt.alternate) end
      end)
    end
    self:emit("end")
  elseif k == "While" then
    self:emit("while " .. self:emit_expression(stmt.test) .. " do")
    self:with_indent(function()
      local guard_var = self:gen_temp("contflag")
      self:emit("local " .. guard_var .. " = false")
      local subctx = { guard_var = guard_var, guard_active = { value = false }, inside_loop = true }
      self:emit_block_with_ctx(stmt.body, subctx)
    end)
    self:emit("end")
  elseif k == "ForRange" then
    local start_code = self:emit_expression(stmt.startExpr)
    local end_code = self:emit_expression(stmt.endExpr)
    self:emit(string.format("for %s = %s, %s do", stmt.var, start_code, end_code))
    self:with_indent(function()
      local guard_var = self:gen_temp("contflag")
      self:emit("local " .. guard_var .. " = false")
      local subctx = { guard_var = guard_var, guard_active = { value = false }, inside_loop = true }
      self:emit_block_with_ctx(stmt.body, subctx)
    end)
    self:emit("end")
  elseif k == "ForEach" then
    local iter = self:emit_expression(stmt.iterExpr)
    local idx = self:gen_temp("i")
    self:emit(string.format("for %s = 1, #(%s) do", idx, iter))
    self:with_indent(function()
      self:emit(string.format("local %s = (%s)[%s]", stmt.var, iter, idx))
      local guard_var = self:gen_temp("contflag")
      self:emit("local " .. guard_var .. " = false")
      local subctx = { guard_var = guard_var, guard_active = { value = false }, inside_loop = true }
      self:emit_block_with_ctx(stmt.body, subctx)
    end)
    self:emit("end")
  elseif k == "Loop" then
    self:emit("while true do")
    self:with_indent(function()
      local guard_var = self:gen_temp("contflag")
      self:emit("local " .. guard_var .. " = false")
      local subctx = { guard_var = guard_var, guard_active = { value = false }, inside_loop = true }
      self:emit_block_with_ctx(stmt.body, subctx)
    end)
    self:emit("end")
  elseif k == "Break" then
    self:emit("break")
  elseif k == "Continue" then
    if not ctx or not ctx.inside_loop then
      self:emit("error('continue used outside of loop')")
    else
      self:emit(ctx.guard_var .. " = true")
      self._encountered_continue = true
    end
  elseif k == "Match" then
    local tmp = self:gen_temp("scrut")
    self:emit("local " .. tmp .. " = " .. self:emit_expression(stmt.discriminant))
    local first = true
    for _, arm in ipairs(stmt.arms) do
      if arm.pattern.kind == "PatternLiteral" then
        local cond = tmp .. " == " .. self:emit_expression(arm.pattern.value)
        if first then
          self:emit("if " .. cond .. " then")
          first = false
        else
          self:emit("elseif " .. cond .. " then")
        end
        self:with_indent(function()
          self:emit_block(arm.body)
        end)
      elseif arm.pattern.kind == "PatternWildcard" then
        if first then
          self:emit("do")
          self:with_indent(function()
            self:emit_block(arm.body)
          end)
          self:emit("end")
          first = false
        else
          self:emit("else")
          self:with_indent(function()
            self:emit_block(arm.body)
          end)
          self:emit("end")
        end
      else
        error("Unsupported match pattern kind: " .. tostring(arm.pattern.kind))
      end
    end
    if not first then
      -- if/elseif/else already emitted end in branches except last elseif case
      -- Ensure an end if last branch wasn't wildcard
      local has_wild = stmt.hasWildcard or false
      if not has_wild then
        self:emit("end")
      end
    end
  elseif k == "Use" then
    local parts = {}
    for i, p in ipairs(stmt.parts) do
      if not (i == 1 and (p == "crate" or p == "self")) then
        table.insert(parts, p)
      end
    end
    local modname = table.concat(parts, ".")
    local localname = stmt.alias or (parts[#parts] or stmt.parts[#stmt.parts])
    if localname then
      self:emit(string.format("local %s = require(%q)", localname, modname))
    else
      self:emit("-- use (ignored): " .. table.concat(stmt.parts, "::"))
    end
  elseif k == "Const" then
    self:emit("local " .. stmt.name .. " = " .. self:emit_expression(stmt.value))
  elseif k == "ExprStmt" then
    local code = self:emit_expression(stmt.expression)
    self:emit(code)
  else
    error("Unknown statement kind: " .. tostring(k))
  end
end

function Emitter:emit_expression(expr)
  local k = expr.kind
  if k == "Literal" then
    if expr.literalType == "string" then
      return string.format("%q", expr.value)
    elseif expr.literalType == "boolean" then
      return expr.value and "true" or "false"
    else
      return tostring(expr.value)
    end
  elseif k == "Identifier" then
    return expr.name
  elseif k == "Unary" then
    local op = to_lua_operator(expr.operator)
    if op == "not" then
      return "not " .. self:emit_expression(expr.argument)
    else
      return op .. self:emit_expression(expr.argument)
    end
  elseif k == "Binary" then
    local op = to_lua_operator(expr.operator)
    return "(" .. self:emit_expression(expr.left) .. " " .. op .. " " .. self:emit_expression(expr.right) .. ")"
  elseif k == "Call" then
    local args = {}
    for _, a in ipairs(expr.arguments) do table.insert(args, self:emit_expression(a)) end
    return self:emit_expression(expr.callee) .. "(" .. table.concat(args, ", ") .. ")"
  elseif k == "Member" then
    return self:emit_expression(expr.object) .. "." .. expr.property
  elseif k == "Index" then
    return self:emit_expression(expr.object) .. "[" .. self:emit_expression(expr.index) .. "]"
  elseif k == "ArrayLiteral" then
    local parts = {}
    for _, e in ipairs(expr.elements) do table.insert(parts, self:emit_expression(e)) end
    return "{" .. table.concat(parts, ", ") .. "}"
  else
    error("Unknown expression kind: " .. tostring(k))
  end
end

return Emitter


